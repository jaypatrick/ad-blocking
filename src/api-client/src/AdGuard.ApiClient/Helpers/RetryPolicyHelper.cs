/*
 * AdGuard DNS API
 *
 * DNS API documentation
 *
 * The version of the OpenAPI document: 1.11
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using AdGuard.ApiClient.Client;
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace AdGuard.ApiClient.Helpers
{
    /// <summary>
    /// Helper class for creating retry policies for API calls.
    /// Provides configurable retry policies for handling transient errors and rate limiting.
    /// </summary>
    /// <remarks>
    /// This class uses Polly for resilience and transient-fault handling.
    /// It provides policies that handle HTTP 429 (Too Many Requests), server errors (5xx),
    /// and request timeouts (408). All policies use exponential backoff by default.
    /// Policies are cached to avoid repeated allocation for common configurations.
    /// </remarks>
    /// <example>
    /// Using the retry helper with an API call:
    /// <code>
    /// var result = await RetryPolicyHelper.ExecuteWithRetryAsync(async () =>
    /// {
    ///     return await api.GetDevicesAsync();
    /// });
    /// </code>
    ///
    /// Creating a custom retry policy:
    /// <code>
    /// var policy = RetryPolicyHelper.CreateDefaultRetryPolicy(maxRetries: 5, initialDelay: 3);
    /// var result = await policy.ExecuteAsync(() => api.GetDevicesAsync());
    /// </code>
    /// </example>
    public static class RetryPolicyHelper
    {
        /// <summary>
        /// Default maximum number of retries.
        /// </summary>
        private const int DefaultMaxRetries = 3;

        /// <summary>
        /// Default initial delay in seconds.
        /// </summary>
        private const int DefaultInitialDelay = 2;

        /// <summary>
        /// Default maximum retries for rate limiting.
        /// </summary>
        private const int DefaultRateLimitMaxRetries = 5;

        /// <summary>
        /// Default base delay for rate limiting in seconds.
        /// </summary>
        private const int DefaultRateLimitBaseDelay = 5;

        /// <summary>
        /// Logger instance for retry operations.
        /// </summary>
        private static ILogger? _logger;

        /// <summary>
        /// Cache for non-generic retry policies to avoid repeated allocation.
        /// </summary>
        private static readonly ConcurrentDictionary<(int maxRetries, int delay), AsyncRetryPolicy> _policyCache = new();

        /// <summary>
        /// Cache for rate limit retry policies to avoid repeated allocation.
        /// </summary>
        private static readonly ConcurrentDictionary<(int maxRetries, int delay), AsyncRetryPolicy> _rateLimitPolicyCache = new();

        /// <summary>
        /// Sets the logger instance for retry operations.
        /// </summary>
        /// <param name="logger">The logger to use for retry operations.</param>
        /// <remarks>
        /// This method should be called during application initialization to enable logging.
        /// If not called, retry operations will not be logged.
        /// </remarks>
        /// <example>
        /// <code>
        /// RetryPolicyHelper.SetLogger(loggerFactory.CreateLogger("RetryPolicy"));
        /// </code>
        /// </example>
        public static void SetLogger(ILogger? logger)
        {
            _logger = logger;
            _logger?.LogInformation("Retry policy logger initialized");
        }

        /// <summary>
        /// Creates a retry policy for handling rate limiting (429) and transient errors.
        /// </summary>
        /// <param name="maxRetries">Maximum number of retries. Must be between 1 and 10. Default is 3.</param>
        /// <param name="initialDelay">Initial delay between retries in seconds. Must be between 1 and 60. Default is 2.</param>
        /// <returns>An async retry policy that handles <see cref="ApiException"/> for retryable errors.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when <paramref name="maxRetries"/> is less than 1 or greater than 10,
        /// or when <paramref name="initialDelay"/> is less than 1 or greater than 60.
        /// </exception>
        /// <remarks>
        /// The policy uses exponential backoff: delay = initialDelay * 2^(retryAttempt-1).
        /// For example, with initialDelay=2: 2s, 4s, 8s, etc.
        /// Policies are cached based on maxRetries and initialDelay to avoid repeated allocation.
        /// </remarks>
        /// <example>
        /// <code>
        /// var policy = RetryPolicyHelper.CreateDefaultRetryPolicy(maxRetries: 5, initialDelay: 3);
        /// await policy.ExecuteAsync(async () => await api.UpdateDeviceAsync(device));
        /// </code>
        /// </example>
        public static AsyncRetryPolicy CreateDefaultRetryPolicy(int maxRetries = DefaultMaxRetries, int initialDelay = DefaultInitialDelay)
        {
            ValidateRetryParameters(maxRetries, initialDelay);

            return _policyCache.GetOrAdd((maxRetries, initialDelay), key =>
            {
                _logger?.LogDebug("Creating and caching retry policy with maxRetries: {MaxRetries}, initialDelay: {InitialDelay}s",
                    key.maxRetries, key.delay);

                return Policy
                    .Handle<ApiException>(ex => IsRetryableException(ex))
                    .WaitAndRetryAsync(
                        key.maxRetries,
                        retryAttempt => TimeSpan.FromSeconds(key.delay * Math.Pow(2, retryAttempt - 1)),
                        onRetry: (exception, timeSpan, retryCount, context) =>
                        {
                            LogRetryAttempt(exception, timeSpan, retryCount, key.maxRetries);
                        }
                    );
            });
        }

        /// <summary>
        /// Creates a typed retry policy for handling rate limiting and transient errors.
        /// </summary>
        /// <typeparam name="T">Return type of the API call.</typeparam>
        /// <param name="maxRetries">Maximum number of retries. Must be between 1 and 10. Default is 3.</param>
        /// <param name="initialDelay">Initial delay between retries in seconds. Must be between 1 and 60. Default is 2.</param>
        /// <returns>An async retry policy that returns type <typeparamref name="T"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when <paramref name="maxRetries"/> or <paramref name="initialDelay"/> are outside valid ranges.
        /// </exception>
        /// <remarks>
        /// Use this overload when you need a strongly-typed policy for methods that return values.
        /// </remarks>
        /// <example>
        /// <code>
        /// var policy = RetryPolicyHelper.CreateDefaultRetryPolicy&lt;List&lt;Device&gt;&gt;(maxRetries: 3);
        /// var devices = await policy.ExecuteAsync(() => api.GetDevicesAsync());
        /// </code>
        /// </example>
        public static AsyncRetryPolicy<T> CreateDefaultRetryPolicy<T>(int maxRetries = DefaultMaxRetries, int initialDelay = DefaultInitialDelay)
        {
            ValidateRetryParameters(maxRetries, initialDelay);

            _logger?.LogDebug("Creating typed retry policy for {Type} with maxRetries: {MaxRetries}, initialDelay: {InitialDelay}s",
                typeof(T).Name, maxRetries, initialDelay);

            return Policy<T>
                .Handle<ApiException>(ex => IsRetryableException(ex))
                .WaitAndRetryAsync(
                    maxRetries,
                    retryAttempt => TimeSpan.FromSeconds(initialDelay * Math.Pow(2, retryAttempt - 1)),
                    onRetry: (result, timeSpan, retryCount, context) =>
                    {
                        if (result.Exception != null)
                        {
                            LogRetryAttempt(result.Exception, timeSpan, retryCount, maxRetries);
                        }
                    }
                );
        }

        /// <summary>
        /// Creates a retry policy specifically for rate limiting (429 errors).
        /// </summary>
        /// <param name="maxRetries">Maximum number of retries. Must be between 1 and 10. Default is 5.</param>
        /// <param name="baseDelay">Base delay between retries in seconds. Must be between 1 and 60. Default is 5.</param>
        /// <returns>An async retry policy that handles HTTP 429 errors with linear backoff.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when <paramref name="maxRetries"/> or <paramref name="baseDelay"/> are outside valid ranges.
        /// </exception>
        /// <remarks>
        /// Unlike <see cref="CreateDefaultRetryPolicy"/>, this policy uses linear backoff: delay = baseDelay * retryAttempt.
        /// This is more appropriate for rate limiting as the server typically needs consistent cooldown periods.
        /// Policies are cached based on maxRetries and baseDelay to avoid repeated allocation.
        /// </remarks>
        /// <example>
        /// <code>
        /// var rateLimitPolicy = RetryPolicyHelper.CreateRateLimitRetryPolicy(maxRetries: 10, baseDelay: 10);
        /// await rateLimitPolicy.ExecuteAsync(async () => await api.BatchUpdateAsync(items));
        /// </code>
        /// </example>
        public static AsyncRetryPolicy CreateRateLimitRetryPolicy(int maxRetries = DefaultRateLimitMaxRetries, int baseDelay = DefaultRateLimitBaseDelay)
        {
            ValidateRetryParameters(maxRetries, baseDelay);

            return _rateLimitPolicyCache.GetOrAdd((maxRetries, baseDelay), key =>
            {
                _logger?.LogDebug("Creating and caching rate limit retry policy with maxRetries: {MaxRetries}, baseDelay: {BaseDelay}s",
                    key.maxRetries, key.delay);

                return Policy
                    .Handle<ApiException>(ex => ex.ErrorCode == 429)
                    .WaitAndRetryAsync(
                        key.maxRetries,
                        retryAttempt => TimeSpan.FromSeconds((double)key.delay * retryAttempt),
                        onRetry: (exception, timeSpan, retryCount, context) =>
                        {
                            _logger?.LogWarning("Rate limit hit (429). Retry {RetryCount}/{MaxRetries} after {Delay:F1}s delay",
                                retryCount, key.maxRetries, timeSpan.TotalSeconds);
                        }
                    );
            });
        }

        /// <summary>
        /// Executes an API call with the default retry policy.
        /// </summary>
        /// <typeparam name="T">Return type of the API call.</typeparam>
        /// <param name="apiCall">The API call function to execute.</param>
        /// <param name="maxRetries">Maximum number of retries. Must be between 1 and 10. Default is 3.</param>
        /// <returns>A task that represents the asynchronous operation, containing the result of type <typeparamref name="T"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="apiCall"/> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="maxRetries"/> is outside valid range.</exception>
        /// <exception cref="ApiException">Thrown when all retry attempts fail.</exception>
        /// <remarks>
        /// This is a convenience method that creates a policy and executes the call in one step.
        /// For multiple calls with the same policy, consider creating the policy once with <see cref="CreateDefaultRetryPolicy{T}"/>.
        /// </remarks>
        /// <example>
        /// <code>
        /// var devices = await RetryPolicyHelper.ExecuteWithRetryAsync(
        ///     async () => await api.GetDevicesAsync(),
        ///     maxRetries: 5
        /// );
        /// </code>
        /// </example>
        public static async Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> apiCall, int maxRetries = DefaultMaxRetries)
        {
            if (apiCall == null)
            {
                _logger?.LogError("API call delegate is null");
                throw new ArgumentNullException(nameof(apiCall), "API call delegate cannot be null.");
            }

            _logger?.LogDebug("Executing API call with retry policy (maxRetries: {MaxRetries})", maxRetries);

            try
            {
                var policy = CreateDefaultRetryPolicy<T>(maxRetries);
                var result = await policy.ExecuteAsync(apiCall);
                _logger?.LogDebug("API call completed successfully");
                return result;
            }
            catch (Exception ex) when (ex is not ArgumentNullException && ex is not ArgumentOutOfRangeException)
            {
                _logger?.LogError(ex, "API call failed after all retry attempts");
                throw;
            }
        }

        /// <summary>
        /// Executes an API call with the default retry policy (void return).
        /// </summary>
        /// <param name="apiCall">The API call function to execute.</param>
        /// <param name="maxRetries">Maximum number of retries. Must be between 1 and 10. Default is 3.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="apiCall"/> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="maxRetries"/> is outside valid range.</exception>
        /// <exception cref="ApiException">Thrown when all retry attempts fail.</exception>
        /// <remarks>
        /// Use this overload for API calls that don't return a value (e.g., delete operations).
        /// </remarks>
        /// <example>
        /// <code>
        /// await RetryPolicyHelper.ExecuteWithRetryAsync(
        ///     async () => await api.DeleteDeviceAsync(deviceId),
        ///     maxRetries: 3
        /// );
        /// </code>
        /// </example>
        public static async Task ExecuteWithRetryAsync(Func<Task> apiCall, int maxRetries = DefaultMaxRetries)
        {
            if (apiCall == null)
            {
                _logger?.LogError("API call delegate is null");
                throw new ArgumentNullException(nameof(apiCall), "API call delegate cannot be null.");
            }

            _logger?.LogDebug("Executing void API call with retry policy (maxRetries: {MaxRetries})", maxRetries);

            try
            {
                var policy = CreateDefaultRetryPolicy(maxRetries);
                await policy.ExecuteAsync(apiCall);
                _logger?.LogDebug("API call completed successfully");
            }
            catch (Exception ex) when (ex is not ArgumentNullException && ex is not ArgumentOutOfRangeException)
            {
                _logger?.LogError(ex, "API call failed after all retry attempts");
                throw;
            }
        }

        /// <summary>
        /// Determines if an API exception should be retried.
        /// </summary>
        /// <param name="exception">The API exception to evaluate.</param>
        /// <returns>True if the exception represents a retryable error; otherwise, false.</returns>
        /// <remarks>
        /// <para>The following HTTP status codes are considered retryable:</para>
        /// <list type="bullet">
        /// <item><description>408 - Request Timeout</description></item>
        /// <item><description>429 - Too Many Requests (rate limiting)</description></item>
        /// <item><description>500-599 - Server errors</description></item>
        /// </list>
        /// <para>Client errors (4xx except 408 and 429) are not retried as they typically indicate
        /// issues with the request that won't be resolved by retrying.</para>
        /// </remarks>
        /// <example>
        /// <code>
        /// // Create a custom Polly retry policy using IsRetryableException
        /// var policy = Policy
        ///     .Handle<ApiException>(ex => RetryPolicyHelper.IsRetryableException(ex))
        ///     .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
        ///
        /// var result = await policy.ExecuteAsync(() => api.GetDeviceAsync(deviceId));
        /// </code>
        /// </example>
        internal static bool IsRetryableException(ApiException exception)
        {
            if (exception == null)
            {
                _logger?.LogDebug("Exception is null, not retryable");
                return false;
            }

            // Retry on rate limiting (429)
            if (exception.ErrorCode == 429)
            {
                _logger?.LogDebug("Exception is rate limit (429), retryable");
                return true;
            }

            // Retry on server errors (5xx)
            if (exception.ErrorCode >= 500 && exception.ErrorCode < 600)
            {
                _logger?.LogDebug("Exception is server error ({ErrorCode}), retryable", exception.ErrorCode);
                return true;
            }

            // Retry on request timeout (408)
            if (exception.ErrorCode == 408)
            {
                _logger?.LogDebug("Exception is request timeout (408), retryable");
                return true;
            }

            _logger?.LogDebug("Exception with error code {ErrorCode} is not retryable", exception.ErrorCode);
            return false;
        }

        /// <summary>
        /// Validates retry parameters and throws if invalid.
        /// </summary>
        /// <param name="maxRetries">Maximum number of retries to validate.</param>
        /// <param name="delay">Delay value to validate.</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when parameters are outside valid ranges.</exception>
        private static void ValidateRetryParameters(int maxRetries, int delay)
        {
            if (maxRetries < 1 || maxRetries > 10)
            {
                _logger?.LogError("Invalid maxRetries value: {MaxRetries}. Must be between 1 and 10", maxRetries);
                throw new ArgumentOutOfRangeException(nameof(maxRetries),
                    $"Maximum retries must be between 1 and 10. Value: {maxRetries}");
            }

            if (delay < 1 || delay > 60)
            {
                _logger?.LogError("Invalid delay value: {Delay}. Must be between 1 and 60 seconds", delay);
                throw new ArgumentOutOfRangeException(nameof(delay),
                    $"Delay must be between 1 and 60 seconds. Value: {delay}");
            }
        }

        /// <summary>
        /// Logs a retry attempt with appropriate detail.
        /// </summary>
        /// <param name="exception">The exception that triggered the retry.</param>
        /// <param name="timeSpan">The delay before the next retry.</param>
        /// <param name="retryCount">The current retry count.</param>
        /// <param name="maxRetries">The maximum number of retries.</param>
        private static void LogRetryAttempt(Exception exception, TimeSpan timeSpan, int retryCount, int maxRetries)
        {
            var errorCode = (exception as ApiException)?.ErrorCode ?? 0;
            var errorMessage = exception.Message;

            _logger?.LogWarning("Retry {RetryCount}/{MaxRetries} after {Delay:F1}s delay. Error code: {ErrorCode}. Message: {Message}",
                retryCount, maxRetries, timeSpan.TotalSeconds, errorCode, errorMessage);
        }
    }
}
